Конспект по основной части книги "Чистый код" Роберта Мартина(Clean Code: A Handbook of Agile Software Craftsmanship) без лишней воды, неточностей и бредовых примеров, а также с некоторыми собственными дополнениями.
# Правильное именование
1) Имена должны отражать намерения программиста; 
2) Они не должны дезориентировать;
3) Должны быть минимальными, но полными: не стоит засорять имена классов/переменных ненужными дополнениями по типу `Info`, `Data`, `Handler`, `Class`, `Table` и т.д. Даже, если класс действительно что-то обрабатывает, эту приписку не стоит добавлять, так как звучит слишком абстрактно. Например, если на данный момент есть `message`(модель) и некий `messageHandler`, стоит посмотреть, в какой доменной области существует `messageHandler`(например, внутри комнаты чата) и скорее всего можно будет понять, что класс отправляет сообщения по вебсокету и переименовать соответственно в что-то по типу `messageWebsocketSender`. Если из доменной области не понятно, можно посмотреть методы класса(они должны быть названы понятно). Если и тут проблема - придется смотреть реализацию, попутно именуя правильно названия методов.
4) Их должно быть удобно искать - как, например, `SESSION_LIFETIME`.
5) Не бойтесь использовать длинные имена. Длинное содержательное имя лучше короткого невразумительного. Выберите схему, которая позволяет легко прочитать слова в имени, а затем составьте из этих слов имя, которое описывает назначение функции/переменной/класса.

Выбор хорошего имени для функции способен в значительной мере объяснить смысл функции, а также порядок и смысл ее аргументов. В унарных(имеющих один аргумент. Также есть нуль-арные, бинарные, тернарные и полиарные) функциях сама функция и ее аргумент должны образовывать естественную пару «глагол/ существительное». Например, вызов вида `write(name)` смотрится весьма информативно, хотя еще лучше запись `setName(value)`.

> Нередко поиски хороших имен приводят к полезной реструктуризации кода.

Также стоит упомянуть, что в некоторых предметных областях есть известные термины, которые не стоит заменять/удлиннять для понятности, так как без знания области, имена переменных не внесут ясности. Самым простым примером является математика - формулы зачастую переписываются точь в точь, чтобы было проще сверять. 

# Функции
## Абстракции функций
ФУНКЦИЯ ДОЛЖНА ВЫПОЛНЯТЬ ТОЛЬКО ОДНУ ОПЕРАЦИЮ. ОНА ДОЛЖНА ВЫПОЛНЯТЬ ЕЕ ХОРОШО. И НИЧЕГО ДРУГОГО ОНА ДЕЛАТЬ НЕ ДОЛЖНА.
Тут встает вопрос - что считать "одной операцией"? Всё предельно просто:
если этапы работы функции находятся на одном уровне абстракции(под объявленным именем функции), то эта функция выполняет одну операцию.

Как пример если в одной функции есть подобное - `getHtml()` — находится на очень высоком уровне абстракции; `String pagePathName = PathParser.render(pagePath)` — на среднем уровне, и, наконец, третьи — такие, как `.append("\n")` — относятся к чрезвычайно низкому уровню абстракции, то функцию нужно разбить!

>В конце концов, функции пишутся прежде всего для разложения более крупной концепции (иначе говоря, имени функции) на последовательность действий на следующем уровне абстракции.

Смешение уровней абстракции внутри функции всегда создает путаницу. _**Читатель не всегда понимает, является ли некоторое выражение важной концепцией или второстепенной подробностью**_. Что еще хуже, при их смешении функция постепенно начинает обрастать все большим количеством второстепенных подробностей.

Функцию, выполняющую только одну операцию, невозможно осмысленно разделить на секции(например, на объявление переменных, их инициализацию и их преобразование).

## Флаги в качестве аргументов
*Флаги* уродливы. Передача логического значения функции — воистину ужасная привычка. Она немедленно усложняет сигнатуру метода, громко провозглашая, что функция выполняет более одной операции. При истинном значении флага выполняется одна операция, а при ложном — другая. 
Это, конечно, **один из компромиссов** программирования - да, он уродует код, ибо SRP не выполняется, но в то же время это скрывает подробности реализации, так как в использующей функции не нужно делать `if-else` - всё ограничивается вызовом одной функции. 

## Чистые функции
Чистая функция — это функция, которая: 
- является детерминированной, то есть не зависит от контекста - при одинаковых входных данных она всегда вернёт один результат;
- не обладает побочными эффектами. 

### Побочные эффекты
Некоторые функции в процессе выполнения своих вычислений могут модифицировать значения глобальных переменных, осуществлять операции ввода-вывода, реагировать на исключительные ситуации, вызывая их обработчики - это побочные эффекты. То есть функция должна получать все необходимые данные в качестве аргументов, использовать их и возвращать результат. 

Да, это удобно, но почему побочные эффекты — плохо? **Ваша функция обещает делать что-то одно, но делает что-то другое, скрытое от пользователя**.

# Комментарии
Комментарии в лучшем случае являются неизбежным злом. Если бы языки программирования были достаточно выразительными или если бы мы умели искусно пользоваться этими языками для выражения своих намерений, то потребность в комментариях резко бы снизилась.

Поэтому каждый раз, когда приходится писать комментарий, стоит задуматься - всё ли в порядке с кодом. Нельзя ли его сделать более простым для понимания?

Тут стоит сказать, чем комментарии плохи:
1) Комментарии зачастую не сопровождаются, и чем древнее комментарий, тем дальше он от того, что на самом деле делает код;
2) Комментарии не раскрывают всю суть кода или же обманывают, выдавая ожидаемое поведение за реальное(такое, конечно, редко встречается у опытных программистов, но надеяться на это не приходится).

# Сокрытие данных
Свойства, спрятанные за интерфейсами, существенно облегчают использование классов - вам не приходится обращаться к абстрактному свойству, которое не понятно как используется, - вы используете функцию, название которой точно определяет её результат. Такие классы и писать проще, и использовать.

## Процедурное программирование
Тут стоит упомянуть про процедурное программирование.
- Процедурный код (код, использующий структуры данных и процедуры для взаимодействия с ними) позволяет легко добавлять новые функции без изменения существующих структур данных. 
- Объектно-ориентированный код, напротив, упрощает добавление новых классов без изменения существующих функций.

Обратные утверждения также истинны. Процедурный код усложняет добавление новых структур данных, потому что оно требует изменения всех функций. Объектно-ориентированный код усложняет добавление новых функций, потому что для этого должны измениться все классы.

Опытные программисты хорошо знают: представление о том, что все данные должны представляться в виде объектов — миф. Иногда предпочтительны простые структуры данных и процедуры, работающие с ними.

### Гибриды
Иногда появляются гибридные структуры — наполовину объектов(свойства скрыты за интерфейсами, предоставляющими методы), наполовину структур данных(публичные данные, не содержащие методы для работы с ними). Гибриды содержат как функции для выполнения важных операций, так и открытые переменные или открытые методы чтения/записи, которые во всех отношениях делают приватные переменные открытыми.

Подобные гибриды усложняют как добавление новых функций, так и новых структур данных. Они объединяют все худшее из обеих категорий. Не используйте гибриды. **Они являются признаком сумбурного проектирования, авторы которого не уверены (или еще хуже, не знают), что они собираются защищать: функции или типы**.

# Исключения
При создании собственного исключения нужно задуматься не о месте, где вы его будете выбрасывать, а о месте, в котором оно будет обрабатываться. Таким образом, сразу становится понятно как его именовать и какую информацию оно должно передавать.

Поэтому всегда лучше начать с блока `try/catch`, а уже потом наследовать `Exception`.

# Интеграция чужого кода
Часто, когда требуется добавить сторонний пакет, возникают трудности с его интеграцией. Если сразу начать вставлять использование пакета в код, задача отладки превратится в ад - это вы неправильные данные отдаете пакету, неправильно его используете или же в пакете ошибка, которую стоит предусмотреть? 
Чтобы этого избежать стоит всего навсего сделать небольшой тестовый проект — сразу и в документации все необходимые вещи станут видны, и вам будет понятно что к чему. 

Учебные тесты позволяют убедиться в том, что сторонние пакеты, используемые в коде, работают именно так, как мы ожидаем.

Чтобы границы со сторонним кодом не создавали проблем в наших проектах, мы сводим к минимуму количество обращений к ним. Для этого можно воспользоваться обертками или реализовать паттерн АДАПТЕР для согласования нашего идеального интерфейса с реальным, полученным от разработчиков. В обоих вариантах код становится более выразительным, обеспечивается внутренняя согласованность обращений через границы, а изменение стороннего кода требует меньших затрат на сопровождение.

# Модульное тестирование
Почему тесты так важны? Они позволяют убедиться в том, что код работает так, как это ожидается, но зачем это нужно? 
1) Код, использующий тестируемые компоненты, знает, что при возникновении ошибки, *проблема именно в этой части программы. В таком случае разработчику не придется лезть куда-то в глубину проекта*, чтобы разобраться, как это исправить, так как используемые компоненты работают правильно. 
2) При внесении изменений можно точно знать, что нигде ничего не поломается - тесты то проходят, а следовательно *расширение программы становится проще*.

==Но этими свойствами обладают только правильно составленные тесты.==

Тесты «на скорую руку» равносильны полному отсутствию тестов, если не хуже. Чем примитивнее тесты, тем труднее их изменять. 
При изменении кода продукта старые тесты перестают проходить, а неразбериха в тестовом коде не позволяет быстро разобраться с возникшими проблемами. Таким образом, тесты начинают рассматриваться как постоянно растущий балласт.

Мораль проста: *тестовый код не менее важен, чем код продукта*. Не считайте его «кодом второго сорта». К написанию тестового кода следует относиться вдумчиво, внимательно и ответственно. Тестовый код должен быть таким же чистым, как и код продукта.

## Чистые тесты
В каждой тестовой функции должна тестироваться одна концепция. Мы не хотим, чтобы длинные тестовые функции выполняли несколько разнородных проверок одну за другой.

Чистые тесты должны обладать еще пятью характеристиками, названия которых образуют приведенное сокращение `F.I.R.S.T`:
- *Fast*. Тесты должны выполняться быстро. Если тесты выполняются медленно, вам не захочется часто запускать их. Без частого запуска тестов проблемы не будут выявляться на достаточно ранней стадии, когда они особенно легко исправляются. 
- *Independent*. Тесты не должны зависеть друг от друга. Один тест не должен создавать условия для выполнения следующего теста. Если тесты зависят друг от друга, то при первом отказе возникает целый каскад сбоев, который усложняет диагностику и скрывает дефекты в зависимых тестах. 
- *Repeatable*. Тесты должны давать повторяемые результаты в любой среде. Вы должны иметь возможность выполнить тесты в среде реальной эксплуатации, в среде тестирования или на вашем ноутбуке во время возвращения домой с работы. Если ваши тесты не будут давать однозначных результатов в любых условиях, вы всегда сможете найти отговорку для объяснения неудач. Также вы лишитесь возможности проводить тестирование, если нужная среда недоступна. 
- *Self-Validating*(Очевидность). Результатом выполнения теста должен быть логический признак. Тест либо прошел, либо не прошел. Чтобы узнать результат, пользователь не должен читать журнальный файл. Не заставляйте его вручную сравнивать два разных текстовых файла. 
- *Timely*(Своевременность). Тесты должны создаваться своевременно. Если вы пишете тесты после кода продукта, вы можете решить, что тестирование кода продукта создает слишком много трудностей, а все из-за того, что удобство тестирования не учитывалось при проектировании кода продукта.

# Разделение ответственности при создании системы
## Инициализация и использование
В программных системах фаза инициализации, в которой конструируются объекты приложения и «склеиваются» основные зависимости, должна отделяться от логики времени выполнения, получающей управление после ее завершения.
Инициализация - такой же модуль системы, как и логика приложения, поэтому нужно вынести создание сущностей и разрешение зависимостей из всех остальных элементов системы.

1) Один из способов отделения конструирования от использования заключается в простом перемещении всех аспектов конструирования в main. Далее весь остальной код системы пишется в предположении, что все объекты были успешно сконструированы и правильно связаны друг с другом.
2) **Dependency Injection** — мощный механизм отделения конструирования от использования, практическое применение *Inversion of Control* в области управления зависимостями. Также большинство контейнеров позволяет использовать все прелести *отложенной инициализации* (объект не создается, пока он не понадобится). Плюсом использования DI является еще и то, что есть другие оптимизации, например, кэширование.

# Заключение
В заключение, хотелось бы предостеречь тех, кто это прочитал, от чтения книги. Несмотря на то, что множество советов очень полезны и найдут своё применение, оставшаяся часть либо не является абсолютной истиной(такие вещи пояснены мной), либо откровенно говоря ужасна(это не попало в конспект). Помимо этого, я уже молчу о примерах хорошего кода, выдвинутых автором, в которых он сам же не соблюдает свои советы.
